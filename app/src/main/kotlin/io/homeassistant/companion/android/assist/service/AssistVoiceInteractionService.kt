package io.homeassistant.companion.android.assist.service

import android.Manifest
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.media.AudioFormat
import android.media.AudioRecord
import android.media.MediaRecorder
import android.os.Build
import android.service.voice.VoiceInteractionService
import androidx.annotation.RequiresPermission
import androidx.core.app.NotificationCompat
import androidx.core.content.ContextCompat
import io.homeassistant.companion.android.assist.AssistActivity
import io.homeassistant.companion.android.assist.wakeword.MicroWakeWord
import io.homeassistant.companion.android.assist.wakeword.MicroWakeWordModel
import io.homeassistant.companion.android.assist.wakeword.TfLiteInitializerImpl
import io.homeassistant.companion.android.common.R as commonR
import kotlin.time.Duration.Companion.seconds
import kotlin.time.TimeSource
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.Job
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.cancel
import kotlinx.coroutines.delay
import kotlinx.coroutines.isActive
import kotlinx.coroutines.launch
import timber.log.Timber

// TODO review thread safety of this class and make it cleaner. It has been generated by Claude

/**
 * Voice interaction service that allows the app to function as the system's default assistant.
 *
 * When the user sets this app as their default assistant, this service is kept running by the
 * system. It can respond to:
 * - Assistant button presses
 * - Lock screen assistant gestures
 * - Voice commands from Bluetooth devices
 * - Wake word detection ("Hey Jarvis") using microWakeWord
 */
class AssistVoiceInteractionService : VoiceInteractionService() {

    private val serviceScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)
    private var audioDetectionJob: Job? = null
    private var audioRecord: AudioRecord? = null
    private var wakeWordDetector: MicroWakeWord? = null

    private var isListening = false
    private var isStartingUp = false
    private var lastTriggerTime: TimeSource.Monotonic.ValueTimeMark? = null

    override fun onReady() {
        super.onReady()
        Timber.d("VoiceInteractionService is ready")
        // Wake word detection is not started automatically - use startListening() to enable
    }

    override fun onShutdown() {
        super.onShutdown()
        Timber.d("VoiceInteractionService is shutting down")
        stopListening()
        serviceScope.cancel()
    }

    override fun onLaunchVoiceAssistFromKeyguard() {
        Timber.d("Launching Assist from keyguard")
        launchAssistActivity()
    }

    /**
     * Start listening for wake word "Hey Jarvis" to trigger the assistant.
     * Requires RECORD_AUDIO permission to be granted.
     */
    fun startListening() {
        if (isListening || isStartingUp) {
            Timber.d("Already listening or starting up")
            return
        }

        if (ContextCompat.checkSelfPermission(this, Manifest.permission.RECORD_AUDIO)
            != PackageManager.PERMISSION_GRANTED
        ) {
            Timber.w("RECORD_AUDIO permission not granted, cannot start listening")
            return
        }

        Timber.d("Starting wake word detection")
        isStartingUp = true

        serviceScope.launch {
            try {
                // Initialize TFLite runtime (required for Play Services TFLite)
                TfLiteInitializerImpl().initialize(this@AssistVoiceInteractionService)

                // Load available wake word models and select the first one
                // TODO: Allow user to select which wake word model to use
                val availableModels = MicroWakeWordModel.loadAvailableModels(this@AssistVoiceInteractionService)
                if (availableModels.isEmpty()) {
                    throw IllegalStateException("No wake word models found in assets")
                }
                val selectedModel = availableModels.first()
                Timber.d("Available wake word models: ${availableModels.map { it.wakeWord }}")

                // Initialize wake word detector with selected model
                wakeWordDetector = MicroWakeWord(this@AssistVoiceInteractionService, selectedModel)
                Timber.d("MicroWakeWord detector initialized with '${selectedModel.wakeWord}'")

                isListening = true
                isStartingUp = false

                launch(Dispatchers.Main) {
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
                        startForeground(
                            NOTIFICATION_ID,
                            createNotification(),
                            android.content.pm.ServiceInfo.FOREGROUND_SERVICE_TYPE_MICROPHONE,
                        )
                    } else {
                        startForeground(NOTIFICATION_ID, createNotification())
                    }
                }
                startAudioDetection()
            } catch (e: Exception) {
                Timber.e(e, "Failed to initialize wake word detection")
                isStartingUp = false
                isListening = false
            }
        }
    }

    /**
     * Stop listening for wake word.
     */
    fun stopListening() {
        if (!isListening) return

        Timber.d("Stopping wake word detection")
        isListening = false
        audioDetectionJob?.cancel()
        audioDetectionJob = null

        audioRecord?.apply {
            try {
                stop()
                release()
            } catch (e: IllegalStateException) {
                Timber.e(e, "Error stopping AudioRecord")
            }
        }
        audioRecord = null

        wakeWordDetector?.close()
        wakeWordDetector = null

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
            stopForeground(STOP_FOREGROUND_REMOVE)
        } else {
            @Suppress("DEPRECATION")
            stopForeground(true)
        }
    }

    private fun startAudioDetection() {
        val sampleRate = SAMPLE_RATE
        val channelConfig = AudioFormat.CHANNEL_IN_MONO
        val audioFormat = AudioFormat.ENCODING_PCM_16BIT
        val bufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat)

        if (bufferSize == AudioRecord.ERROR_BAD_VALUE || bufferSize == AudioRecord.ERROR) {
            Timber.e("Invalid buffer size for AudioRecord: $bufferSize")
            stopListening()
            return
        }

        // Use a buffer size that's a multiple of our chunk size (160 samples = 10ms)
        val chunkSize = CHUNK_SIZE_SAMPLES
        val adjustedBufferSize = maxOf(bufferSize, chunkSize * 4)

        try {
            audioRecord = AudioRecord(
                MediaRecorder.AudioSource.MIC,
                sampleRate,
                channelConfig,
                audioFormat,
                adjustedBufferSize,
            )
        } catch (e: SecurityException) {
            Timber.e(e, "Security exception creating AudioRecord")
            stopListening()
            return
        }

        if (audioRecord?.state != AudioRecord.STATE_INITIALIZED) {
            Timber.e("AudioRecord failed to initialize")
            audioRecord?.release()
            audioRecord = null
            stopListening()
            return
        }

        audioRecord?.startRecording()

        audioDetectionJob = serviceScope.launch {
            val buffer = ShortArray(chunkSize)

            while (isActive && isListening) {
                val readResult = audioRecord?.read(buffer, 0, buffer.size) ?: -1

                if (readResult > 0) {
                    // Process audio through wake word detector
                    val detector = wakeWordDetector
                    if (detector != null) {
                        val detected = detector.processAudio(buffer.copyOf(readResult))

                        if (detected) {
                            val now = TimeSource.Monotonic.markNow()
                            val lastTrigger = lastTriggerTime

                            // Debounce: only trigger if enough time has passed
                            if (lastTrigger == null || (now - lastTrigger) > DEBOUNCE_DURATION) {
                                Timber.i("Wake word 'Hey Jarvis' detected!")
                                lastTriggerTime = now
                                launchAssistActivity()

                                // Wait before listening again to avoid retriggering
                                delay(DEBOUNCE_DURATION.inWholeMilliseconds)

                                // Reset detector state after trigger
                                detector.reset()
                            }
                        }
                    }
                } else if (readResult < 0) {
                    Timber.e("AudioRecord read error: $readResult")
                    break
                }
            }
        }
    }

    private fun launchAssistActivity() {
        val intent = Intent(this, AssistActivity::class.java).apply {
            addFlags(Intent.FLAG_ACTIVITY_NEW_TASK)
        }
        startActivity(intent)
    }

    private fun createNotification(): Notification {
        createNotificationChannel()

        val stopIntent = Intent(this, AssistVoiceInteractionService::class.java).apply {
            action = ACTION_STOP_LISTENING
        }
        val stopPendingIntent = PendingIntent.getService(
            this,
            0,
            stopIntent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE,
        )

        return NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle(getString(commonR.string.assist_listening_title))
            .setContentText(getString(commonR.string.assist_listening_wakeword))
            .setSmallIcon(commonR.drawable.ic_stat_ic_notification)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .setOngoing(true)
            .addAction(
                commonR.drawable.ic_stat_ic_notification,
                getString(commonR.string.assist_stop_listening),
                stopPendingIntent,
            )
            .build()
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                CHANNEL_ID,
                getString(commonR.string.assist_listening_channel),
                NotificationManager.IMPORTANCE_LOW,
            ).apply {
                description = getString(commonR.string.assist_listening_channel_description)
                setShowBadge(false)
            }

            val notificationManager = getSystemService(NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_START_LISTENING -> startListening()
            ACTION_STOP_LISTENING -> stopListening()
        }
        return super.onStartCommand(intent, flags, startId)
    }

    companion object {
        private const val CHANNEL_ID = "assist_listening"
        private const val NOTIFICATION_ID = 9001

        private const val ACTION_START_LISTENING = "io.homeassistant.companion.android.START_LISTENING"
        private const val ACTION_STOP_LISTENING = "io.homeassistant.companion.android.STOP_LISTENING"

        private const val SAMPLE_RATE = 16000
        private const val CHUNK_SIZE_SAMPLES = 160 // 10ms at 16kHz
        private val DEBOUNCE_DURATION = 3.seconds

        /**
         * Check if this VoiceInteractionService is currently the active system assistant.
         */
        fun isActiveService(context: Context): Boolean {
            val componentName = android.content.ComponentName(
                context,
                AssistVoiceInteractionService::class.java,
            )
            return isActiveService(context, componentName)
        }

        /**
         * Start listening for wake word.
         *
         * Requires [Manifest.permission.RECORD_AUDIO] permission to access the microphone.
         */
        @RequiresPermission(Manifest.permission.RECORD_AUDIO)
        fun startListening(context: Context) {
            val intent = Intent(context, AssistVoiceInteractionService::class.java).apply {
                action = ACTION_START_LISTENING
            }
            context.startService(intent)
        }

        /**
         * Stop listening for wake word.
         */
        fun stopListening(context: Context) {
            val intent = Intent(context, AssistVoiceInteractionService::class.java).apply {
                action = ACTION_STOP_LISTENING
            }
            context.startService(intent)
        }
    }
}
